<html>
  <head>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script> delete AFRAME.components["grabbable"]; </script>
    <script src="https://unpkg.com/aframe-environment-component@1.5.x/dist/aframe-environment-component.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@c-frame/aframe-physics-system@4.1.0/dist/aframe-physics-system.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.x/dist/aframe-extras.min.js"></script>
    <script src="https://unpkg.com/super-hands@3.0.5/dist/super-hands.min.js"></script>
  </head>
  <body>
    <a-scene renderer="antialias:true;colorManagement:true;physicallyCorrectLights:true"
      xr-mode-ui="enabled: true"
      webxr="optionalFeatures: bounded-floor, hand-tracking"
      cursor="rayOrigin: mouse; fuse: false"
      raycaster="objects: .raycastable"
      physics="debug: false">

      <a-entity 
        id="player" 
        position="0 0 0" 
        joystick-locomotion="moveSpeed: 0.1; turnSpeed: 2">
      
        <a-camera></a-camera>

        <a-entity id="left-hand-rig">
          <a-entity super-hands hand-controls="hand: left" sphere-collider="objects: .interactable" dynamic-body>
            <a-entity class="grab-socket" position="0 0 -0.1" rotation="0 0 0"></a-entity>
          </a-entity>
        </a-entity>
        <a-entity  id="right-hand-rig">
          <a-entity super-hands hand-controls="hand: right" sphere-collider="objects: .interactable">
            <a-entity class="grab-socket" position="0 0 -0.1" rotation="0 0 0"></a-entity>
          </a-entity>
        </a-entity>

        <!--<a-entity id="leftHand" laser-controls="hand: left" raycaster="objects: .raycastable"   ></a-entity>
        <a-entity id="rightHand" laser-controls="hand: right" raycaster="objects: .raycastable" ></a-entity>

        <a-entity sphere-collider="objects: a-box" hand-tracking-controls="hand: left;"></a-entity>
        <a-entity sphere-collider="objects: a-box" hand-tracking-controls="hand: right;"></a-entity>
          sphere-collider="objects: a-box"
          sphere-collider="objects: a-box"
        <a-entity sphere-collider="objects: a-box" super-hands hand-controls="hand: left"></a-entity>
        <a-entity sphere-collider="objects: a-box" super-hands hand-controls="hand: right"></a-entity>-->

      </a-entity>
      
      <a-box 
        position="-1 1.5 -5" 
        rotation="0 45 0" 
        color="#4CC3D9" 
        scale="0.5 0.5 0.5"
        shadow="receive: true; cast:true;" 
        dynamic-body
        class="interactable"
        grabbable
        hoverable
        draggable
        droppable
        stretchable 
        highlight-on-hover
        physics-grab="offset: 0 0 -0.2; rotation: 0 90 0"
        ></a-box>
      <a-sphere 
        position="1 2 -5" 
        radius="0.25" 
        color="#EF2D5E" 
        shadow="receive: true; cast:true;" 
        dynamic-body
        class="interactable"
        hoverable 
        grabbable 
        stretchable 
        draggable 
        droppable 
        highlight-on-hover
        physics-grab="offset: 0 0 -0.2; rotation: 0 90 0"
        ></a-sphere>

      <a-box 
        position="0 0.25 -5" 
        rotation="0 0 0" 
        color="brown" 
        shadow="receive: true; cast:true;" 
        depth="1.2" 
        height="1" 
        width="5" 
        static-body
        ></a-box>

      <a-plane scale="100 100 100" position="0 -.1 0" rotation="90 0 0" static-body></a-plane>

      <a-entity light="type:directional; castShadow:true;" position="1 1 1"></a-entity>
      <a-entity light="type: ambient; color: #111"></a-entity>
      <a-sky color="#ECECEC"></a-sky>

      <a-entity
        position="0 1.6 0"
        camera look-controls="magicWindowTrackingEnabled: false; touchEnabled: false; mouseEnabled: false">
        <a-entity
          id="fadeBackground"
          geometry="primitive: sphere; radius: 2.5"
          material="color: #999999; side: back; shader: flat; blending: subtractive;" visible="false">
        </a-entity>
      </a-entity>

      <a-entity environment="preset: forest" shadow="receive: true"></a-entity>
      
    </a-scene>
  </body>

  <script>
    AFRAME.registerComponent('joystick-locomotion', {
      schema: {
        moveSpeed: { type: 'number', default: 0.1 },
        turnSpeed: { type: 'number', default: 2 },
        deadZone: { type: 'number', default: 0.01 }
      },

      init() {
        this.leftGamepad = null;
        this.rightGamepad = null;

        this.el.sceneEl.addEventListener('enter-vr', () => {
          const xrSession = this.el.sceneEl.renderer.xr.getSession();
          if (!xrSession) return;

          xrSession.addEventListener('inputsourceschange', () => {
            this.updateControllers(xrSession);
          });

          this.updateControllers(xrSession); // aussi au premier enter-vr
        });
      },

      updateControllers(xrSession) {
        const inputSources = xrSession.inputSources;
        this.leftGamepad = null;
        this.rightGamepad = null;

        inputSources.forEach((source) => {
          if (!source.gamepad) return;

          if (source.handedness === 'left') {
            this.leftGamepad = source.gamepad;
          } else if (source.handedness === 'right') {
            this.rightGamepad = source.gamepad;
          }
        });
      },

      tick() {
        const rig = this.el;
        const pos = rig.getAttribute('position');
        const rot = rig.getAttribute('rotation');

        // === Déplacement avec stick gauche ===
        if (this.leftGamepad && this.leftGamepad.axes.length >= 2) {
          const [lx, ly] = [this.leftGamepad.axes[2], this.leftGamepad.axes[3]];
          const mag = Math.sqrt(lx * lx + ly * ly);

          if (mag > this.data.deadZone) {
            const angleRad = THREE.MathUtils.degToRad(rot.y);
            const dx = (ly * Math.sin(angleRad) + lx * Math.cos(-angleRad)) * this.data.moveSpeed;
            const dz = (ly * Math.cos(angleRad) + lx * Math.sin(-angleRad)) * this.data.moveSpeed;

            rig.setAttribute('position', {
              x: pos.x + dx,
              y: pos.y,
              z: pos.z + dz
            });
          }
        }

        // === Rotation avec stick droit ===
        if (this.rightGamepad && this.rightGamepad.axes.length >= 4) {
          const [rx, ry] = [this.rightGamepad.axes[2], this.rightGamepad.axes[3]];
          if (Math.abs(rx) > this.data.deadZone) {
            rig.setAttribute('rotation', {
              x: rot.x,
              y: rot.y - rx * this.data.turnSpeed,
              z: rot.z
            });
          }
        }
      }
    });

    AFRAME.registerComponent('highlight-on-hover', {
      schema: {
        color: {type: 'color', default: '#FFD700'} // or couleur originale stockée
      },

      init: function () {
        const el = this.el;
        this.originalColor = (el.getAttribute('material') || {}).color || '#FFF';

        el.addEventListener('hover-start', () => {
          el.setAttribute('material', 'color', this.data.color);
        });

        el.addEventListener('hover-end', () => {
          el.setAttribute('material', 'color', this.originalColor);
        });
      }
    });


    AFRAME.registerComponent('physics-grab', {
      schema: {
        socketClass: {type: 'string', default: '.grab-socket'},
        offset: {type: 'vec3', default: {x: 0, y: 0, z: 0}},
        rotation: {type: 'vec3', default: {x: 0, y: 0, z: 0}}
      },

      init: function () {
        const el = this.el;

        el.addEventListener('grab-start', (evt) => {
          const tracked = hand.components['tracked-controls'];
          if (!tracked || !tracked.controller || !tracked.controller.gamepad) return;
          if (gamepad.buttons[1]?.pressed) {
            let target = evt.detail.target;
            target.object3D.position.set(this.data.offset.x, this.data.offset.y, this.data.offset.z);
            target.object3D.rotation.set(this.data.rotation.x, this.data.rotation.y, this.data.rotation.z);
            evt.detail.hand.querySelector(this.data.socketClass).add(target);

            const mesh = hand.getObject3D('mesh');
            if (mesh) mesh.visible = false;
          }
          /*el.removeAttribute('dynamic-body');

          const hand = evt.detail.hand;
          let handPos = hand.getAttribute('position');
          let handRot = hand.getAttribute('rotation');
          const socket = hand.querySelector(this.data.socketClass);

          if (socket) {

            el.object3D.position.set(0, 0, 0);
            el.object3D.rotation.set(0, 0, 0);

            socket.add(el);

            /*const socketPos = socket.getAttribute('position');
            const socketRot = socket.getAttribute('rotation');
            el.object3D.position.set(
              this.data.offset.x + socketPos.x,
              this.data.offset.y + socketPos.y,
              this.data.offset.z + socketPos.z
            );
            el.object3D.rotation.set(
              HREE.MathUtils.degToRad(this.data.rotation.x) + socketRot.x,
              HREE.MathUtils.degToRad(this.data.rotation.y) + socketRot.y,
              HREE.MathUtils.degToRad(this.data.rotation.z) + socketRot.z
            );

          }*/
        });

        el.addEventListener('grab-end', (evt) => {
          el.setAttribute('dynamic-body', '');

          el.sceneEl.add(el);

          /*const velocity = evt.detail.linearVelocity || {x:0,y:0,z:0};
          const angularVelocity = evt.detail.angularVelocity || {x:0,y:0,z:0};

          el.addEventListener('body-loaded', () => {
            el.body.velocity.set(velocity.x, velocity.y, velocity.z);
            el.body.angularVelocity.set(angularVelocity.x, angularVelocity.y, angularVelocity.z);
            let handPos = hand.getAttribute('position');
            let handRot = hand.getAttribute('rotation');
            el.object3D.position.set(handPos.x, handPos.y, handPos.z);
            el.object3D.rotation.set(
              THREE.MathUtils.degToRad(handRot.x),
              THREE.MathUtils.degToRad(handRot.y),
              THREE.MathUtils.degToRad(handRot.z)
            );
          }, {once:true});

          const hand = evt.detail.hand;
          const mesh = hand.getObject3D('mesh');
          if (mesh) mesh.visible = true;*/
        });
      }
    });




    /*const playerRig = document.querySelector("#player")

    function controllerReady(el) {
      const tc = el.components['tracked-controls'];
      return !!(tc && tc.controller && tc.controller.gamepad);
    }

    AFRAME.registerComponent("player-move-controls", {
      schema: {
        speed: {type: 'float', default: .1}
      },

      init: function() {

        this.el.addEventListener('axismove', (e) => {
          const [x, y] = e.detail.axis;
          let position = playerRig.getAttribute("position");
          console.log(position);

          playerRig.setAttribute('position', {
            x: position.x + y * this.data.speed, 
            y: position.y, 
            z: position.z + x * this.data.speed
          });
        });

      },
      
      tick: function() {

      }
    });

    AFRAME.registerComponent("player-rotation-controls", {
      schema: {
        speed: {type: 'float', default: 1.0}
      },

      init: function() {
        this.el.addEventListener('axismove', (e) => {
          const [x, y] = e.detail.axis;
          let rotation = playerRig.getAttribute("rotation");
          console.log(rotation, this.data.speed, rotation.y + y * this.data.speed);
          
          playerRig.setAttribute('rotation', {
            x: rotation.x + y * this.data.speed,
            y: rotation.y, 
            z: rotation.z + x * this.data.speed
          });

          console.log(playerRig.getAttribute("rotation"));
        });
      },
      
      tick: function() {

      }
    });*/
    
  </script>
</html>
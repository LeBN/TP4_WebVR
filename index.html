<html>
  <head>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.5.x/dist/aframe-environment-component.min.js"></script>
  </head>
  <body>
    <a-scene renderer="antialias:true;colorManagement:true;physicallyCorrectLights:true"
      xr-mode-ui="enabled: true"
      webxr="optionalFeatures: bounded-floor, hand-tracking"
      cursor="rayOrigin: mouse; fuse: false"
      raycaster="objects: .raycastable">

      <a-entity 
        id="player" 
        position="0 0 0" 
        joystick-locomotion="moveSpeed: 0.1; turnSpeed: 2">
      
        <a-camera></a-camera>

        <a-entity sphere-collider="objects: a-box" id="leftHand" laser-controls="hand: left" raycaster="objects: .raycastable"   ></a-entity>
        <a-entity sphere-collider="objects: a-box" id="rightHand" laser-controls="hand: right" raycaster="objects: .raycastable" ></a-entity>

        <a-entity sphere-collider="objects: a-box" hand-tracking-controls="hand: left;"></a-entity>
        <a-entity sphere-collider="objects: a-box" hand-tracking-controls="hand: right;"></a-entity>

        <!--<a-entity sphere-collider="objects: a-box" super-hands hand-controls="hand: left"></a-entity>
        <a-entity sphere-collider="objects: a-box" super-hands hand-controls="hand: right"></a-entity>-->

      </a-entity>
      
      <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9" shadow="receive: true; cast:true;"></a-box>
      <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E" shadow="receive: true; cast:true;"></a-sphere>

      <a-entity light="type:directional; castShadow:true;" position="1 1 1"></a-entity>
      <a-entity light="type: ambient; color: #111"></a-entity>
      <a-sky color="#ECECEC"></a-sky>

      <a-entity
        position="0 1.6 0"
        camera look-controls="magicWindowTrackingEnabled: false; touchEnabled: false; mouseEnabled: false">
        <a-entity
          id="fadeBackground"
          geometry="primitive: sphere; radius: 2.5"
          material="color: #999999; side: back; shader: flat; blending: subtractive;" visible="false">
        </a-entity>
      </a-entity>

      <a-entity environment shadow="receive: true"></a-entity>
      
    </a-scene>
  </body>

  <script>
    AFRAME.registerComponent('joystick-locomotion', {
      schema: {
        moveSpeed: { type: 'number', default: 0.1 },
        turnSpeed: { type: 'number', default: 2 }, // degrés/frame
        deadZone:  { type: 'number', default: 0.2 }
      },

      init() {
        this.gamepads = [];
      },

      tick() {
        const pads = navigator.getGamepads ? navigator.getGamepads() : [];

        this.gamepads = pads.filter(p => p && p.connected && p.pose);

        let leftStick = [0, 0];
        let rightStick = [0, 0];

        // Trouve les axes des manettes gauche/droite
        for (let pad of this.gamepads) {
          const isLeft = pad.handedness === 'left';
          const isRight = pad.handedness === 'right';
          const axes = pad.axes;

          if (isLeft && axes.length >= 2) {
            leftStick = [axes[0], axes[1]]; // x, y
          }
          if (isRight && axes.length >= 4) {
            rightStick = [axes[2], axes[3]]; // x, y
          }
        }

        const rig = this.el;
        const position = rig.getAttribute('position');
        const rotation = rig.getAttribute('rotation');

        // ===== Déplacement avant/arrière/strafing (stick gauche) =====
        const [lx, ly] = leftStick;
        const magLeft = Math.sqrt(lx * lx + ly * ly);
        if (magLeft > this.data.deadZone) {
          // Calcul de direction par rapport à la rotation Y
          const angle = THREE.MathUtils.degToRad(rotation.y);
          const dx = (-ly * Math.sin(angle) + lx * Math.cos(angle)) * this.data.moveSpeed;
          const dz = (-ly * Math.cos(angle) - lx * Math.sin(angle)) * this.data.moveSpeed;

          rig.setAttribute('position', {
            x: position.x + dx,
            y: position.y,
            z: position.z + dz
          });
        }

        // ===== Rotation yaw (stick droit) =====
        const [rx, ry] = rightStick;
        if (Math.abs(rx) > this.data.deadZone) {
          rig.setAttribute('rotation', {
            x: rotation.x,
            y: rotation.y + rx * this.data.turnSpeed,
            z: rotation.z
          });
        }
      }
    });

    /*const playerRig = document.querySelector("#player")

    function controllerReady(el) {
      const tc = el.components['tracked-controls'];
      return !!(tc && tc.controller && tc.controller.gamepad);
    }

    AFRAME.registerComponent("player-move-controls", {
      schema: {
        speed: {type: 'float', default: .1}
      },

      init: function() {

        this.el.addEventListener('axismove', (e) => {
          const [x, y] = e.detail.axis;
          let position = playerRig.getAttribute("position");
          console.log(position);

          playerRig.setAttribute('position', {
            x: position.x + y * this.data.speed, 
            y: position.y, 
            z: position.z + x * this.data.speed
          });
        });

      },
      
      tick: function() {

      }
    });

    AFRAME.registerComponent("player-rotation-controls", {
      schema: {
        speed: {type: 'float', default: 1.0}
      },

      init: function() {
        this.el.addEventListener('axismove', (e) => {
          const [x, y] = e.detail.axis;
          let rotation = playerRig.getAttribute("rotation");
          console.log(rotation, this.data.speed, rotation.y + y * this.data.speed);
          
          playerRig.setAttribute('rotation', {
            x: rotation.x + y * this.data.speed,
            y: rotation.y, 
            z: rotation.z + x * this.data.speed
          });

          console.log(playerRig.getAttribute("rotation"));
        });
      },
      
      tick: function() {

      }
    });*/
    
  </script>
</html>